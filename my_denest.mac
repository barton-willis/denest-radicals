/* Maxima code for denesting some radicals
   
   Copyright 2022, Barton Willis

   This program is free software: you can redistribute it and/or modify it under the 
   terms of the GNU General Public License as published by the Free Software Foundation, 
   either version 3 of the License, or (at your option) any later version. This 
   program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; 
   without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR 
   PURPOSE. See the GNU General Public License for more details.You should have 
   received a copy of the GNU General Public License along with this 
   program. If not, see <https://www.gnu.org/licenses/>. 
*/   

/* Predicates for identifying +, *, and ^ expressions. */

mplusp(e) := not mapatom(e) and inpart(e,0) = "+";

mtimesp(e) := not mapatom(e) and inpart(e,0) = "*";

mexptp(e) := not mapatom(e) and inpart(e,0) = "^";

map('load, [to_poly_solve, "opsubst"]);

/* First, gfactor eq. Second, for every term in e of the form a^q, where a 
   and q are rational, factor eq over the field of rationals with 
   g^denom(q) - a adjoined. After factoring, replace g by a^(1/denom(q)). */
algebraic_factor(eq,e) := block([g : gensym()],
   eq : gfactor(eq),
   e : gatherargs(e,"^"),
   e : sublist(e, lambda([q], ratnump(first(q)) and ratnump(second(q)))),
   e : setify(e),
   for ek in e do (
      eq : factor(eq, g^denom(second(ek)) - first(ek)),
      eq : subst(first(ek)^(1/denom(second(ek))),g,eq)),
   eq);

/* Return p is a polynomial in the variable x of the form c4*x^4+c2*x^2+c0, where
   c0,c2, and c4 are free of x. */
biquadratic_p(p,x) := (
  p : expand(p),
  polynomialp(p,[x]) and hipow(p,x) = 4 and coeff(p,x,4) # 0 and coeff(p,x,3) = 0 and coeff(p,x,1) = 0);

/* Return a list of the roots of a biquadratic polynomial c0 + c2*x^2 + x^4. 
When possible, this function returns the roots as non-nested radicals. 
Example: solve_biquartic(1,1,x) compared to solve(x^4+x^2+1,x). */   

solve_biquartic(c0,c2,x) := block([a,b],
  a : radcan((2*sqrt(c0)-c2)/4),
  b : radcan(-(c2+2*sqrt(c0))/4),
  /* When a=b, this is still correct, but x=0 is listed twice */
  [x=sqrt(a)+sqrt(b),x=-sqrt(a)+sqrt(b), x=sqrt(a)-sqrt(b), x=-sqrt(a)-sqrt(b)]);

/* Solve the quartic polynomial p = c0 + c1 x + c2 x^2 + c3 x^3 + c4 x^4 for x, 
   returning non-nested radical solutions when possible, and otherwise return 
   the empty list. There are non-nested solutions for both the biquartic case and 
   when 8*c1*c4^2-4*c2*c3*c4+c3^3 = 0. */

solve_quartic_surd_only(p,x) := block([c0,c1,c2,c3,c4,a,b,c, prederror : false],
  p : rat(p,x),
  c4 : ratcoeff(p,x,4),
  [c0,c1,c2,c3] : map(lambda([k], ratcoeff(p,x,k)/c4), [0,1,2,3]),
  if (c1=0) and (c3=0) then (
     solve_biquartic(c0,c2,x))
  elseif ratsimp(c3^3-4*c2*c3+8*c1)=0 and every('ratnump, [c0,c1,c2,c3]) then (
     factor(solve(p,x)))
  else []);    

/* For every factor of e that has degree three or less, solve. Do not attempt to 
   solve factors that are degree four or more. */
solve_degree_four_or_less(e,x) := block([algexact : true, solvefactors : true, 
          solveexplicit : true, dontfactor : [],sol : [],n],
   e : if mtimesp(e) then args(e) else [e],
   for ex in e do (
      n : hipow(ex,x),
      if n=4 then sol : append(solve_quartic_surd_only(ex,x),sol)
      elseif n < 4 then sol : append(solve(ex,x), sol)),
   sol);   

/* The sqrtdenest function isn't in core for some Maxima versions, so conditionally 
   load sqdnst. I don't know a way to test this using user level functions.*/
if not ?get('sqrtdenest, '?impl\-name) then load(sqdnst);

/* If q^n = e, that is if q is an nth root of e, return
   q*exp(2iπk/n), where k is an integer that makes 
   arg(q*exp(2iπk/n)) a member of (-π/n,π]. If the test 
   q^n = e fails, return false.*/

  principalize_root(q,n,e) := block([k],
   if is(equal(radcan(rootscontract(expand(q^n))),e)) then (
      k : floor(1/2 - n*carg(q)/(2*%pi)),
      if integerp(k) then expand(rectform(exp(2*%pi*%i*k/n))*q) else false)
   else false);   

/* To help solve find un-nested solutions, we will precondition the
   equations using algebraic_factor (that also automatically calls 
   gfactor). The function solve_degree_three_factors declines to 
   attempt to solve any factor of degree four or greater. Possibly
   restricing solve this way misses some de-nestings. 
   
   Maybe the setting of solvedecomposes matters?
   */

denest_helper(e,n) := block([eq, ee : false, g : gensym(),sol, ker],
   /* For the square root case, call sqrtdenest */
      if n=2 then (
      ee : sqrtdenest(sqrt(e))),

   if surd_p(ee) then ee
   else (  

   /* eq = polynomial with one solution is g = e^(1/n). */
	eq : first(to_poly(e - g^n,[g,1])),        
	eq : first(first(elim_allbut(eq, g))),
	/* Solve eq for g. We hope that solve returns non-nested radicals when possible.*/ 
    eq : algebraic_factor(eq,e),
    sol : solve_degree_four_or_less(eq, g),
	 sol : map(lambda([s], block([algebraic : true], ratsimp(s))), sol),

   /* Build the list of solutions [aaa,bbb, ...] instead of [g = aaa, g = bbb, ...]. 
	   Also, remove redundant solutions. */
	sol : map(lambda([solk], subst(solk,g)), unique(sol)),
   
	/* Remove solutions that are not complex numbers or surds */
	sol : sublist(sol, lambda([q], complex_number_p(q) or surd_p(q))), 
   
	/* Convert non-spurious roots to the principal root. Spurious roots
      are converted to false, so delete false from the result of mapping. */
   sol : map(lambda([s], principalize_root(s,n,e)), sol),
   sol : delete(false, sol), 

   /* When no solutions are found, push e^(1/n) onto the sol. */
	if emptyp(sol) then push(e^(1/n), sol),

	/* Sort sol according to the sorting predicate ?complexity and 
      return the first list member. Maybe we should have a specialized
      predicate for sorting? */
    first(sort(sol, lambda([a,b], ?complexity(a) < ?complexity(b))))));

/* Return true iff e is a complex number whose real and imaginary parts are
   rational numbers.*/
complex_rational_p(e) :=
  complex_number_p(e) and ratnump(realpart(e)) and ratnump(imagpart(e));
  
/* Return true iff e is a sum of complex rational numbers and terms of the form
   n^(p/q), where p & q are integers and n is a complex rational number.*/
surd_p(e):=block([inflag:true],
    xreduce("or",
    [complex_rational_p(e),
     (mexptp(e) and complex_rational_p(first(e)) and ratnump(second(e)) and 
	       not integerp(second(e))),
     ((mplusp(e) or mtimesp(e)) and every('surd_p,args(e)))]));

denest_single_radical(e) := block([opsubst : true, inflag : true],
    subst("^" = lambda([a,b], if mplusp(a) and surd_p(a) and ratnump(b) then denest_helper(a,denom(b))^num(b) else a^b), e)); 

denest(e) := scanmap(lambda([q], ratsimp(denest_single_radical(q))), e, 'bottomup);