/* Maxima code for denesting some radicals
   
   Copyright 2022, Barton Willis

   This program is free software: you can redistribute it and/or modify it under the 
   terms of the GNU General Public License as published by the Free Software Foundation, 
   either version 3 of the License, or (at your option) any later version. This 
   program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; 
   without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR 
   PURPOSE. See the GNU General Public License for more details.You should have 
   received a copy of the GNU General Public License along with this 
   program. If not, see <https://www.gnu.org/licenses/>. 
*/   

/* Predicates for identifying +, *, and ^ expressions. */

mplusp(e) := not mapatom(e) and inpart(e,0) = "+";

mtimesp(e) := not mapatom(e) and inpart(e,0) = "*";

mexptp(e) := not mapatom(e) and inpart(e,0) = "^";

map('load, [to_poly_solve, "opsubst"]);

/* First, gfactor eq. Second, for every term in e of the form a^q, where a 
   and q are rational, factor eq over the field of rationals with 
   g^denom(q) - a adjoined. After factoring, replace g by a^(1/denom(q)). */
algebraic_factor(eq,e) := block([g : gensym()],
   eq : gfactor(eq),
   e : gatherargs(e,"^"),
   e : sublist(e, lambda([q], ratnump(first(q)) and ratnump(second(q)))),
   e : setify(e),
   for ek in e do (
      eq : factor(eq, g^denom(second(ek)) - first(ek)),
      eq : subst(first(ek)^(1/denom(second(ek))),g,eq)),
   eq);

/* For every factor of e that has degree three or less, solve. Do not attempt to 
   solve factors that are degree four or more. */
solve_degree_three_factors(e,x) := block([algexact : true, solvefactors : true, 
          solveexplicit : true, dontfactor : [],sol : []],
   e : if mtimesp(e) then args(e) else [e],
   for ex in e do (
      if hipow(ex,x) < 4 then sol : append(solve(ex,x), sol)),
   sol);   

/* The sqrtdenest function isn't in core for some Maxima versions, so conditionally 
   load sqdnst. I don't know a way to test this using user level functions.*/
if not ?get('sqrtdenest, '?impl\-name) then load(sqdnst);

/* If q^n = e, that is if q is an nth root of e, return
   q*exp(2iπk/n), where k is an integer that makes 
   arg(q*exp(2iπk/n)) a member of (-π/n,π]. If the test 
   q^n = e fails, return false.*/

  principalize_root(q,n,e) := block([k],
   if is(equal(rootscontract(expand(q^n)),e)) then (
      k : floor(1/2 - n*carg(q)/(2*%pi)),
      if integerp(k) then expand(rectform(exp(2*%pi*%i*k/n))*q) else false)
   else false);   

/* To help solve find un-nested solutions, we will precondition the
   equations using algebraic_factor (that also automatically calls 
   gfactor). The function solve_degree_three_factors declines to 
   attempt to solve any factor of degree four or greater. Possibly
   restricing solve this way misses some de-nestings. 
   
   Maybe the setting of solvedecomposes matters?
   */

denest_helper(e,n) := block([eq, ee : false, g : gensym(),sol, ker],
   /* For the square root case, call sqrtdenest */
      if n=2 then (
      ee : sqrtdenest(sqrt(e))),

   if surd_p(ee) then ee
   else (  

   /* eq = polynomial with one solution is g = e^(1/n). */
	eq : first(to_poly(e - g^n,[g,1])),        
	eq : first(first(elim_allbut(eq, g))),
	/* Solve eq for g. We hope that solve returns non-nested radicals when possible.*/ 
    eq : algebraic_factor(eq,e),
    sol : solve_degree_three_factors(eq, g),
	 sol : map(lambda([s], block([algebraic : true], ratsimp(s))), sol),

   /* Build the list of solutions [aaa,bbb, ...] instead of [g = aaa, g = bbb, ...]. 
	   Also, remove redundant solutions. */
	sol : map(lambda([solk], subst(solk,g)), unique(sol)),
   
   
	/* Remove solutions that are not complex numbers or surds */
	sol : sublist(sol, lambda([q], complex_number_p(q) or surd_p(e))), 
   
	/* Convert non-spurious roots to the principal root. Spurious roots
      are converted to false, so delete false from the result of mapping. */
   sol : map(lambda([s], principalize_root(s,n,e)), sol),
   sol : delete(false, sol), 

   /* When no solutions are found, push e^(1/n) onto the sol. */
	if emptyp(sol) then push(e^(1/n), sol),

	/* Sort sol according to the sorting predicate ?complexity and 
      return the first list member. Maybe we should have a specialized
      predicate for sorting? */
    first(sort(sol, lambda([a,b], ?complexity(a) < ?complexity(b))))));

/* Return true iff e is a complex number whose real and imaginary parts are
   rational numbers.*/
complex_rational_p(e) :=
  complex_number_p(e) and ratnump(realpart(e)) and ratnump(imagpart(e));
  
/* Return true iff e is a sum of complex rational numbers and terms of the form
   n^(p/q), where p & q are integers and n is a complex rational number.*/
surd_p(e):=block([inflag:true],
    xreduce("or",
    [complex_rational_p(e),
     (mexptp(e) and complex_rational_p(first(e)) and ratnump(second(e)) and 
	       not integerp(second(e))),
     ((mplusp(e) or mtimesp(e)) and every('surd_p,args(e)))]));

denest_single_radical(e) := block([opsubst : true, inflag : true],
    subst("^" = lambda([a,b], if mplusp(a) and surd_p(a) and ratnump(b) then denest_helper(a,denom(b))^num(b) else a^b), e)); 

denest(e) := scanmap(lambda([q], ratsimp(denest_single_radical(q))), e, 'bottomup);